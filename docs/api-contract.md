# Password Protection API Contract

This document defines the API contract for the password protection backend service.

## Base URL

The backend API should be accessible at a configurable base URL (e.g., `https://api.example.com` or `https://your-backend.vercel.app`).

## Authentication

The API uses Bearer token authentication for protected content access. Tokens are obtained through password verification and should be included in the `Authorization` header.

## Endpoints

### 1. Verify Password

**POST** `/api/verify-password`

Verifies a password for a specific content item and returns an authentication token.

#### Request Body

```typescript
{
  type: 'notes' | 'publications' | 'ideas' | 'pages'
  slug: string
  password: string
}
```

#### Response

**Success (200 OK)**
```typescript
{
  success: true
  token: string  // JWT or session token for subsequent requests
  message?: string
}
```

**Error (401 Unauthorized)**
```typescript
{
  success: false
  message: string  // e.g., "Invalid password"
}
```

**Error (404 Not Found)**
```typescript
{
  success: false
  message: string  // e.g., "Content not found"
}
```

**Error (429 Too Many Requests)**
```typescript
{
  success: false
  message: string  // e.g., "Too many attempts, please try again later"
}
```

### 2. Get Protected Content

**GET** `/api/protected-content/:type/:slug`

Retrieves the full content for a protected item after successful authentication.

#### Path Parameters

- `type`: Content type (`notes`, `publications`, `ideas`, `pages`)
- `slug`: Content slug

#### Headers

```
Authorization: Bearer <token>
```

#### Response

**Success (200 OK)**
```typescript
{
  slug: string
  title: string
  date: string
  readTime: string
  type: string
  excerpt: string
  content: string  // Raw markdown content
  html: string     // Processed HTML content
}
```

**Error (401 Unauthorized)**
```typescript
{
  error: "Invalid or expired token"
}
```

**Error (404 Not Found)**
```typescript
{
  error: "Content not found"
}
```

## Data Source

The backend should read protected content from the `protected-content.json` file generated by the frontend build process. This file contains the full content for all protected items.

### File Structure

```json
{
  "notes": [
    {
      "slug": "private-note",
      "title": "Private Note",
      "date": "2025-01-15",
      "readTime": "3 min",
      "type": "note",
      "excerpt": "This is a private note...",
      "content": "# Private Note\n\nThis content is protected...",
      "html": "<h1>Private Note</h1><p>This content is protected...</p>",
      "isProtected": true
    }
  ],
  "publications": [],
  "ideas": [],
  "pages": []
}
```

## Security Requirements

1. **Password Hashing**: Passwords should be hashed using bcrypt with appropriate salt rounds (minimum 12)
2. **Token Security**: JWT tokens should have reasonable expiration times (e.g., 24 hours)
3. **Rate Limiting**: Implement rate limiting on password verification (e.g., 5 attempts per IP per minute)
4. **HTTPS**: All API endpoints must be served over HTTPS
5. **Input Validation**: Validate all input parameters and sanitize content
6. **CORS**: Configure CORS appropriately for the frontend domain

## Error Handling

All endpoints should return appropriate HTTP status codes and consistent error message formats. The frontend expects:

- `200` for successful operations
- `401` for authentication failures
- `404` for not found
- `429` for rate limiting
- `500` for server errors

## Example Implementation

### Password Verification Logic

```javascript
// Pseudo-code for password verification
async function verifyPassword(type, slug, password) {
  // 1. Load protected content from protected-content.json
  const protectedContent = await loadProtectedContent();
  
  // 2. Find the content item
  const content = protectedContent[type]?.find(item => item.slug === slug);
  if (!content) {
    return { success: false, message: "Content not found" };
  }
  
  // 3. Verify password (you'll need to store password hashes separately)
  const isValid = await bcrypt.compare(password, content.passwordHash);
  if (!isValid) {
    return { success: false, message: "Invalid password" };
  }
  
  // 4. Generate and return token
  const token = jwt.sign({ type, slug }, secret, { expiresIn: '24h' });
  return { success: true, token };
}
```

### Content Retrieval Logic

```javascript
// Pseudo-code for content retrieval
async function getProtectedContent(type, slug, token) {
  // 1. Verify token
  const decoded = jwt.verify(token, secret);
  if (decoded.type !== type || decoded.slug !== slug) {
    throw new Error("Invalid token");
  }
  
  // 2. Load and return content
  const protectedContent = await loadProtectedContent();
  const content = protectedContent[type]?.find(item => item.slug === slug);
  
  if (!content) {
    throw new Error("Content not found");
  }
  
  return content;
}
```

## Frontend Integration

The frontend will:

1. Check if content is protected (`isProtected: true`)
2. Show password modal if not authenticated
3. Call `/api/verify-password` with user input
4. Store token in sessionStorage on success
5. Call `/api/protected-content/:type/:slug` with token
6. Display the retrieved content

## Testing

The backend should include:

1. Unit tests for password verification
2. Unit tests for content retrieval
3. Integration tests for the full flow
4. Rate limiting tests
5. Security tests (token validation, input sanitization)
